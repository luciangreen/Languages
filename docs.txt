# List Prolog Interpreter

# Prerequisites

* Please download and install SWI-Prolog for your machine at https://www.swi-prolog.org/build/.

* You may need to install gawk using Homebrew.

* Install <a href="https://github.com/soimort/translate-shell">Translation Shell</a> on Mac, etc.
Change line in & culturaltranslationtool/ctt.pl
concat_list(["../../../trans ",FromLang,":",ToLang," '",Input1,"'"],F),
&
to correct location of <a href="https://github.com/soimort/translate-shell">trans</a>.

# 1. Install manually

Download <a href="http://github.com/luciangreen/listprologinterpreter/">this repository</a>, the <a href="https://github.com/luciangreen/Languages">Languages repository</a> and <a href="https://github.com/luciangreen/culturaltranslationtool">Cultural Translation Tool</a> into the same folder.

# 2. Or Installation from List Prolog Package Manager (LPPM)

* Download the <a href="https://github.com/luciangreen/List-Prolog-Package-Manager">LPPM Repository</a>:

&
git clone https://github.com/luciangreen/List-Prolog-Package-Manager.git
cd List-Prolog-Package-Manager
swipl
['lppm'].
lppm_install("luciangreen","listprologinterpreter")
halt
&

# Running

* Download the repository to your machine.
In the SWI-Prolog environment, enter:
cd listprologinterpreter
swipl
['listprolog'].

* Running the tests
To run all tests, enter:
&test(off,NTotal,Score).&

* To run a specific test:
&test1(off,TestNumber,Passed).&
where TestNumber is the test number from <a href="https://github.com/luciangreen/listprologinterpreter/blob/master/lpiverify4.pl">lpiverify4.pl</a>.

* The query &test1(off,7,Passed).& tests the reverse predicate:
test(7,`[[n,reverse],[[1,2,3],[],[v,l]]]`,
`[[[n,reverse],[[],[v,l],[v,l]]],[[n,reverse],[[v,l],[v,m],[v,n]],":-",[[[n,head],[[v,l],[v,h]]],[[n,tail],[[v,l],[v,t]]],[[n,wrap],[[v,h],[v,h1]]],[[n,append],[[v,h1],[v,m],[v,o]]],[[n,reverse],[[v,t],[v,o],[v,n]]]]]]`,
`[[[v,l], [3, 2, 1]]]`).


# Documentation

* The interpreter is called in the form:
&international_interpret([lang,en]&,debug,query,type_statements,mode_statements,functions,result).

Where:
debug - on or off for trace,
query - the query e.g. [[n,reverse],[[1,2,3],[],[v,l]]]
type statements - e.g. [[n,reverse],[[[t,list],[[t,number]]],[[t,list],[[t,number]]],[[t,list],[[t,number]]]]]
mode statements - e.g. [[n,reverse],[input,input,output]]
functions - the algorithm e.g. see reverse above
result - the result, e.g. [[[v,l], [3, 2, 1]]] ([] indicates failed and [[]] indicates the empty list).

* Statements may be negated in the form:

`[[n,not],[statement]]`

* Statements may be connected by the disjunctive (or):

`[[n,or],[statements1,statements2]]`

* If-then statements may either be in the form:

`[[n,"->"],[statements1,statements2]]`

This means "If Statements1 then Statements2".

* Or, if-then statements may be in the form:

`[[n,"->"],[statements1,statements2,statements2a]]`

This means "If Statements1 then Statements2, else Statements2a".

* `[[n,+],[1,2,[v,b]]]` `[v,b]=3`
* `[[n,-],[1,2,[v,b]]]` `[v,b]=(-1)`
* `[[n,*],[1,2,[v,b]]]` `[v,b]=2`
* `[[n,/],[1,2,[v,b]]]` `[v,b]=0.5`

* `[[n,cut]]` - behaves like swipl's ! (doesn't allow backtracking forward or back past it)

* `[[n,true]]` - behaves like true

* `[[n,fail]]` - fails the current predicate

* `[[n,atom],[variable]]`, e.g. `[[n,atom],[[v,a]]]` - returns true if `[v,a]='a'`, an atom

* `[[n,string],[variable]]`, e.g. `[[n,string],[[v,a]]]` - returns true if `[v,a]="a"`, a string

* `[[n,number],[variable]]`, e.g. `[[n,number],[14]]` - returns true where `14` is a number

* `[[n,letters],[variable]]`, e.g. `[[n,letters],["abc"]]` - returns true where `"abc"` is letters

* `[[n,is_operator],[variable1,variable2]]`, where `is_operator=is` or `is_operator="="`, e.g. `[[n,=],[[v,a],1]]` - returns true if `[v,a]=1`

* `[[n,comparison_operator],[variable1,variable2]]`, where comparison_operator=">",">=","<", "=<", "=" or =\= e.g. `[[n,>=],[1,2]]` - returns (1>=2)=false.

* `[[n,equals1],[variable1,[variable2,variable3]]]` e.g. `[[n,equals1],[["a","b"],[[v,a],[v,b]]]]` returns `[v,a]="a"` and `[v,b]="b"`

* `[[n,equals2],[variable1,[variable2,variable3]]]` e.g. `[[n,equals2],[[v,a],["a","b"]]]` returns `[v,a]=["a","b"]`

* `[[n,equals3],[variable1,variable2]]` e.g. `[[n,equals3],[[v,a],[1,2,3]]]` returns `[v,a]=[1,2,3]`

* `[[n,wrap],[variable1,variable2]]` e.g. `[[n,wrap],["a",[v,b]]]` returns `[v,b]=["a"]`

* `[[n,unwrap],[variable1,variable2]]` e.g. `[[n,wrap],[["a"],[v,b]]]` returns `[v,b]="a"`

* `[[n,head],[variable1,variable2]]` e.g. `[[n,head],[["a","b","c"],[v,b]]]` returns `[v,b]="a"`

* `[[n,tail],[variable1,variable2]]` e.g. `[[n,tail],[["a","b","c"],[v,b]]]` returns `[v,b]=["b","c"]`

* `[[n,member],[variable1,variable2]]` e.g. `[[n,member],[["a","b","c"],[v,b]]]` returns `[v,b]="a"`, `[v,b]="b"` or `[v,b]="c"`, or e.g. `[[n,member],[["a","b","c"],"c"]]` returns true.

* `[[n,member2],[variable1,variable2]]` e.g. `[[n,member2],[["a","b","c"],[v,b]]]` returns `[v,b]="a"`, `[v,b]="b"` or `[v,b]="c"`

* `[[n,delete],[variable1,variable2,variable3]]` e.g. `[[n,delete],[["a","b","b","c"],"b",[v,c]]]` returns `[v,c]=["a","c"]`

* `[[n,append],[variable1,variable2,variable3]]` e.g. `[[n,append],[["a","b"],["c"],[v,d]]]` returns `[v,d]=["a","b","c"]`.  Note: variable2 must be in list form, not e.g. `"c"`, or the command will fail.  Wrap may wrap in [].

* `[[n,stringconcat],[variable1,variable2,variable3]]` e.g. `[[n,stringconcat],["hello ","john",[v,c]]]` returns `[v,c]="hello john"`.

* `[[n,stringtonumber],[variable1,variable2]]` e.g. `[[n,stringtonumber],["3",[v,b]]]` returns `[v,b]=3`

* `[[n,random],[variable1]]` e.g. `[[n,random],[[v,r]]]` returns e.g. `[v,r]=0.19232608946956326`

* `[[n,length],[variable1,variable2]]` e.g. `[[n,length],[[1,2,3],[v,l]]]` returns `[v,l]=3`

* `[[n,ceiling],[variable1,variable2]]` e.g. `[[n,ceiling],[0.19232608946956326,[v,c]]]` returns `[v,c]=1`

* `[[n,date],[year,month,day,hour,minute,seconds]]` e.g. `[[n,date],[[v,year],[v,month],[v,day],[v,hour],[v,minute],[v,second]]]` returns e.g. `[v,year]=2019`, `[v,month]=11`, `[v,day]=6`, `[v,hour]=12`, `[v,minute]=15`, `[v,second]=20.23353409767151`.

* `[[n,sqrt],[variable1,variable2]]` e.g. `[[n,ceiling],[4,[v,c]]]` returns `[v,c]=2`

* `[[n,round],[variable1,variable2]]` e.g. `[[n,round],[1.5,[v,c]]]` returns `[v,c]=2`

* `[[n,equals4],[variable1,variable2]]` e.g. `[[n,equals4],[[[v,c],"|",[v,d]],[1,2,3]]]` returns `[v,c]=1` and `[v,d]=[2,3]`.  You may use either order (i.e. a=1 or 1=a).  Multiple items are allowed in the head of the list, there may be lists within lists, and lists with pipes must have the same number of items in the head in each list, or no pipe in the other list.

* `[[n,findall],[variable1,variable2,variable3]]` e.g. `[[[n,equals3],[[v,a],[1,2,3]]],[[n,findall],[[v,a1],[[n,member2],[[v,a],[v,a1]]],[v,b]]]]` returns `[v,b]=[1,2,3]`

* `[[n,string_from_file],[variable1,variable2]]` e.g. `[[n,string_from_file],[[v,a],"file.txt"]]` returns `[v,a]="Hello World"`

* `[[n,maplist],[variable1,variable2,variable3,variable4]]` e.g. `[[n,maplist],[[n,+],[1,2,3],0,[v,b]]]` returns `[v,b]=6`


# Grammars

* List Prolog supports grammars, for example:


test(8,`[[n,grammar1],["apple"]]`,
`[[[n,grammar1],[[v,s]],":-",[[[n,noun],[[v,s],""]]]],[[n,noun],"->",["apple"]]]`,
`[[]]`).

* In `[[n,noun],[[v,s],""]]`, the argument `[v,s]` is the entry string and `""` is the exit string.

* In the above example, the word `"apple"` is parsed.  Grammars use `"->"`, not `":-"`.

* Grammars may be recursive (see test 9 in <a href="https://github.com/luciangreen/listprologinterpreter/blob/master/lpiverify4.pl">lpiverify4.pl</a>), i.e. they may repeat until triggering the base case.

* Grammars may have extra arguments, placed after the other arguments.  The entry and exit string arguments are only used outside the grammar, and can be accessed, e.g.:
`[[n,look_ahead],[[v,a],[v,a],[v,b]],":-",[[[n,stringconcat],[[v,b],[v,d],[v,a]]]]]`		  
Note: `":-"`, not `"->"`  
		
		
* Base cases for recursive grammars require e.g.
`[[n,compound212],["","",[v,t],[v,t]]]`

and a "bottom case" in case it is not at the end of the string, e.g.:
`[[n,compound212],[[v,u],[v,u],[v,t],[v,t]]]`

given the clause:
`[[n,compound21],[[v,t],[v,u]],"->",[[[n,a]],[[n,code],[[n,wrap],["a",[v,itemname1]]],[[n,append],[[v,t],[v,itemname1],[v,v]]]],[[n,compound212],[[v,v],[v,u]]]]]`,

In it, `[[n,a]]` calls a grammar predicate called `"a"`.  `[[n,code],codes]` is similar to {} in SWI-Prolog (it allows commands to be called within a grammar).  The code wraps a string and appends it to a list, before exiting code and calling the grammar predicate `compound212`.  `v` and `u` are not entry and exit strings, they are extra arguments, handled with `t` in the base cases above.

* Sometimes there is another recursive clause, which calls itself:
`[[n,compound21],[[v,t],[v,u]],"->",[[[n,a]],",",[[n,compound21],[[],[v,compound1name]]],[[n,code],[[n,wrap],["a",[v,itemname1]]],[[n,append],[[v,t],[v,itemname1],[v,v]]],[[n,append],[[v,v],[v,compound1name],[v,u]]]]]]`
		  
`[[n,a]]`, a call, could be substituted with `[v,b]`, however `[[n,a]]` would call a grammar predicate and `[v,b]` would return a character.

* When we need to find out what the next character is but parse the character somewhere else, we use look_ahead.

E.g.:
`[[n,word21],[[v,t],[v,u]],"->",[[v,a],[[n,commaorrightbracketnext]],[[n,code],[[n,letters],[[v,a]]],[[n,stringconcat],[[v,t],[v,a],[v,v]]]],[[n,word212],[[v,v],[v,u]]]]]`

With `commaorrightbracketnext` (which looks ahead for a comma or `"]"`), it doesn't return true in `"a"` of `"ab,c"`
and goes to `"b"` instead as wanted.

* Note, we can call `look_ahead` as a grammar predicate:
`[[n,look_ahead],["ate"]]`

even though the predicate itself is not a grammar predicate:
`[[n,look_ahead],[[v,a],[v,a],[v,b]],":-",[[[n,stringconcat],[[v,b],[v,d],[v,a]]]]]`

* Predicates or predicates to modify to provide the function of string to list (test 15), split on character(s) (test 17), `intersection` and `minus` are in <a href="https://github.com/luciangreen/listprologinterpreter/blob/master/lpiverify4.pl">lpiverify4.pl</a>.

# Functional List Prolog (FLP)

* List Prolog has an optional functional mode.  In FLP, function calls may be passed as variables and functions may have strong types.

* In the following, `[[n,function],[[[n,function2],[2]],1,1,[v,c]]]` function2 is passed as a variable.  `[v,f11]` is replaced with the function name.

%% c=f((g(2)), 1, 1)
test(53,`[[n,function],[[[n,function2],[2]],1,1,[v,c]]]`,
[
`[[n,function],[[v,f1],[v,a],[v,b],[v,c]],":-",[[[n,equals1],[[v,f1],[[v,f11],[v,f12]]]],[[n,getitemn],[1,[v,f12],[v,bb]]],[[v,f11],[[v,bb],[v,d],[v,f]]],[[n,+],[[v,a],[v,b],[v,e]]],[[n,+],[[v,e],[v,f],[v,g]]],[[n,+],[[v,g],[v,d],[v,c]]]]]`,
`[[n,function2],[[v,bb],[v,a],[v,f]],":-",[[[n,is],[[v,a],[v,bb]]],[[n,is],[[v,f],1]]]]`,
`[[n,getitemn],[1,[v,b],[v,c]],":-",[[[n,head],[[v,b],[v,c]]]]]`,
`[[n,getitemn],[[v,a],[v,b],[v,c]],":-",[[[n,not],[[[n,=],[[v,a],0]]]],[[n,tail],[[v,b],[v,t]]],[[n,-],[[v,a],1,[v,d]]],[[n,getitemn],[[v,d],[v,t],[v,c]]]]]`
]
,`[[[[v,c], 5]]]`).
